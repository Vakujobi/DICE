<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Pastel Physics Dice (2 Dice + Popup + Sound)</title>

  <style>
    html, body { height:100%; }

    body{
      margin:0;
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: linear-gradient(180deg, #f8f5ff 0%, #f7fff8 45%, #fff7f2 100%);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    #ui{
      position:fixed;
      left:0; right:0;
      bottom: calc(16px + env(safe-area-inset-bottom));
      display:flex;
      justify-content:center;
      pointer-events:none;
      z-index: 10;
    }
    #btnRow{
      display:flex;
      gap:12px;
      align-items:center;
      pointer-events:auto;
      flex-wrap: wrap;
      justify-content:center;
      padding: 0 12px;
    }
    button{
      border:0;
      padding: 14px 22px;
      border-radius:16px;
      background:#1a1a1a;
      color:#fff;
      font-weight:900;
      font-size: clamp(14px, 3.8vw, 16px);
      cursor:pointer;
      box-shadow:0 12px 28px rgba(0,0,0,.16);
      touch-action: manipulation;
    }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .result{
      font-weight:900;
      color:#1a1a1a;
      background: rgba(255,255,255,.65);
      padding: 9px 12px;
      border-radius:14px;
      backdrop-filter: blur(8px);
      box-shadow:0 10px 22px rgba(0,0,0,.08);
      pointer-events:none;
      min-width: min(260px, 90vw);
      text-align:center;
      font-size: clamp(13px, 3.6vw, 15px);
    }

    /* Sound toggle */
    #soundWrap{
      position: fixed;
      right: 14px;
      bottom: calc(14px + env(safe-area-inset-bottom));
      z-index: 20;
      background: rgba(255,255,255,.65);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(0,0,0,.06);
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow:0 10px 22px rgba(0,0,0,.08);
      display:flex;
      align-items:center;
      gap:10px;
      color:#111;
      font-weight: 900;
      font-size: clamp(12px, 3.4vw, 14px);
      user-select: none;
    }
    #soundToggle{
      width: 44px;
      height: 28px;
      border-radius: 999px;
      background: rgba(0,0,0,.15);
      position: relative;
      cursor: pointer;
      border: 0;
      padding: 0;
    }
    #soundKnob{
      position:absolute;
      top: 4px;
      left: 4px;
      width: 20px;
      height: 20px;
      border-radius: 999px;
      background:#111;
      transition: transform 140ms ease;
    }
    #soundToggle.on #soundKnob{ transform: translateX(16px); }

    /* Popup modal */
    #modalBackdrop{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.25);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 50;
      padding: 18px;
    }
    #modal{
      width: min(520px, 96vw);
      border-radius: 18px;
      background: rgba(255,255,255,.82);
      backdrop-filter: blur(12px);
      box-shadow: 0 24px 60px rgba(0,0,0,.20);
      border: 1px solid rgba(0,0,0,.08);
      padding: 18px 18px 14px;
    }
    #modalTop{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 12px;
      margin-bottom: 10px;
    }
    #modalTitle{
      font-weight: 950;
      letter-spacing: .2px;
      color: #111;
      font-size: 16px;
    }
    #closeModal{
      border:0;
      background: rgba(17,17,17,.08);
      color:#111;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 900;
      cursor:pointer;
    }
    #closeModal:hover{ background: rgba(17,17,17,.12); }

    #modalBig{
      font-size: clamp(38px, 8vw, 48px);
      font-weight: 1000;
      color:#111;
      line-height: 1.05;
      margin: 8px 0 6px;
    }
    #modalSub{
      font-weight: 850;
      color: rgba(17,17,17,.78);
      margin-bottom: 10px;
      font-size: clamp(13px, 3.8vw, 15px);
    }
    #modalQuote{
      background: rgba(255,255,255,.65);
      border: 1px solid rgba(0,0,0,.06);
      border-radius: 14px;
      padding: 12px 12px;
      color:#111;
      font-weight: 750;
      line-height: 1.35;
      font-size: clamp(13px, 3.8vw, 15px);
    }

    /* Error box */
    #err{
      position:fixed;
      top:12px; left:12px; right:12px;
      background:#fff3f3;
      color:#111;
      padding:12px 14px;
      border-radius:12px;
      box-shadow:0 10px 20px rgba(0,0,0,.15);
      font: 14px/1.35 system-ui;
      display:none;
      z-index: 9999;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>
  <div id="err"></div>

  <div id="ui">
    <div id="btnRow">
      <button id="roll">ROLL</button>
      <div class="result">
        Die A: <span id="outA">—</span> &nbsp;|&nbsp; Die B: <span id="outB">—</span>
      </div>
    </div>
  </div>

  <div id="soundWrap" title="Sound on/off">
    Sound
    <button id="soundToggle" class="on" aria-label="Toggle sound">
      <span id="soundKnob"></span>
    </button>
  </div>

  <div id="modalBackdrop" role="dialog" aria-modal="true">
    <div id="modal">
      <div id="modalTop">
        <div id="modalTitle">What is this number telling you?</div>
        <button id="closeModal">Close</button>
      </div>
      <div id="modalBig">—</div>
      <div id="modalSub">—</div>
      <div id="modalQuote">—</div>
    </div>
  </div>

  <script type="module">
    // On-screen errors
    const errBox = document.getElementById("err");
    const showErr = (msg) => { errBox.style.display = "block"; errBox.textContent = msg; };
    window.addEventListener("error", (e) => showErr("JS Error:\n" + (e.message || e.error || "Unknown")));
    window.addEventListener("unhandledrejection", (e) => showErr("Promise Error:\n" + (e.reason?.message || e.reason || "Unknown")));

    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import * as CANNON from "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js";

    const rollBtn = document.getElementById("roll");
    const outA = document.getElementById("outA");
    const outB = document.getElementById("outB");

    // Modal elements
    const modalBackdrop = document.getElementById("modalBackdrop");
    const closeModalBtn = document.getElementById("closeModal");
    const modalBig = document.getElementById("modalBig");
    const modalSub = document.getElementById("modalSub");
    const modalQuote = document.getElementById("modalQuote");

    function openModal({ combined, a, b, quote }){
      modalBig.textContent = combined;
      modalSub.textContent = `You rolled ${a} and ${b} → combined: ${combined}`;
      modalQuote.textContent = quote;
      modalBackdrop.style.display = "flex";
    }
    function closeModal(){ modalBackdrop.style.display = "none"; }
    closeModalBtn.addEventListener("click", closeModal);
    modalBackdrop.addEventListener("click", (e) => { if (e.target === modalBackdrop) closeModal(); });
    window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeModal(); });

    // Quote generator (combined = concatenation)
    function funQuoteFor(a, b){
      const combined = Number(`${a}${b}`);
      const sum = a + b;

      if (a === b) {
        const doubles = [
          "Doubles! That’s not luck — that’s the universe hitting ‘repeat’ because you didn’t hear it the first time.",
          "Doubles energy. Whatever you’re thinking… do it twice as boldly.",
          "Double trouble, double blessing. Today wants you to move with confidence, not caution."
        ];
        return { combined, quote: doubles[combined % doubles.length] };
      }
      if (sum === 7) return { combined, quote: "Seven vibes. You’re in the sweet spot where chaos turns into comedy — take the risk, but make it fun." };
      if (sum === 11) return { combined, quote: "Eleven energy. Main-character timing — something small you do today will look legendary later." };

      const moods = [
        "Today is for bold moves and soft landing.",
        "Quiet confidence wins louder than noise.",
        "Do it messy. Do it anyway.",
        "Small step now, big flex later.",
        "If it feels scary, it’s probably the right door.",
        "You’re closer than your doubt wants you to believe."
      ];
      const twists = [
        "Add a little swagger to your plan.",
        "Text that person. Yes, today.",
        "Say yes to the thing you keep postponing.",
        "Stop overthinking and press play.",
        "One brave decision = new timeline.",
        "Go with the option that makes you smile."
      ];
      const mood = moods[combined % moods.length];
      const twist = twists[(combined + sum) % twists.length];
      return { combined, quote: `${combined}? That’s your sign. ${mood} ${twist}` };
    }

    // ---------- SOUND (Web Audio) ----------
    let audioCtx = null;
    let soundOn = true;

    const soundToggle = document.getElementById("soundToggle");
    soundToggle.addEventListener("click", async () => {
      soundOn = !soundOn;
      soundToggle.classList.toggle("on", soundOn);
      if (soundOn) {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state !== "running") await audioCtx.resume();
      }
    });

    async function ensureAudio(){
      if (!soundOn) return false;
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state !== "running") await audioCtx.resume();
      return true;
    }

    function gainNode(value){
      const g = audioCtx.createGain();
      g.gain.value = value;
      g.connect(audioCtx.destination);
      return g;
    }

    function playDing(){
      if (!audioCtx || !soundOn) return;
      const t = audioCtx.currentTime;
      const notes = [880, 1175];
      notes.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, t + i*0.03);
        const g = gainNode(0.0001);
        g.gain.setValueAtTime(0.0001, t + i*0.03);
        g.gain.exponentialRampToValueAtTime(0.18, t + i*0.03 + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t + i*0.03 + 0.25);
        osc.connect(g);
        osc.start(t + i*0.03);
        osc.stop(t + i*0.03 + 0.28);
      });
    }

    // roll sound: rumble + clacks
    function playRollSequence(){
      if (!audioCtx || !soundOn) return;
      const t0 = audioCtx.currentTime;

      const dur = 0.55;
      const buffer = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * dur), audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0; i<data.length; i++){
        const x = i / data.length;
        data[i] = (Math.random()*2-1) * Math.pow(1 - x, 2.5) * 0.65;
      }

      const rumble = audioCtx.createBufferSource();
      rumble.buffer = buffer;

      const bp = audioCtx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = 320;
      bp.Q.value = 0.9;

      const g = gainNode(0.0001);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.18, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      rumble.connect(bp);
      bp.connect(g);
      rumble.start(t0);
      rumble.stop(t0 + dur + 0.02);

      const clacks = [0.06, 0.14, 0.23, 0.33, 0.45, 0.58];
      clacks.forEach((dt, idx) => {
        const vol = 0.22 - idx*0.02;

        const osc = audioCtx.createOscillator();
        osc.type = "sine";
        osc.frequency.setValueAtTime(220 + Math.random()*80, t0 + dt);

        const tapGain = gainNode(0.0001);
        tapGain.gain.setValueAtTime(0.0001, t0 + dt);
        tapGain.gain.exponentialRampToValueAtTime(vol, t0 + dt + 0.004);
        tapGain.gain.exponentialRampToValueAtTime(0.0001, t0 + dt + 0.045);
        osc.connect(tapGain);

        const nb = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate*0.03), audioCtx.sampleRate);
        const nd = nb.getChannelData(0);
        for (let i=0; i<nd.length; i++){
          const x = i/nd.length;
          nd[i] = (Math.random()*2-1) * (1-x);
        }
        const noise = audioCtx.createBufferSource();
        noise.buffer = nb;

        const hp = audioCtx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = 1200;

        const noiseGain = gainNode(0.0001);
        noiseGain.gain.setValueAtTime(0.0001, t0 + dt);
        noiseGain.gain.exponentialRampToValueAtTime(vol*0.55, t0 + dt + 0.003);
        noiseGain.gain.exponentialRampToValueAtTime(0.0001, t0 + dt + 0.03);

        noise.connect(hp);
        hp.connect(noiseGain);

        osc.start(t0 + dt);
        osc.stop(t0 + dt + 0.06);

        noise.start(t0 + dt);
        noise.stop(t0 + dt + 0.04);
      });
    }

    // ---------- THREE ----------
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xf7f4ff, 10, 26);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);

    function fitCamera(){
      const portrait = window.innerHeight > window.innerWidth;
      if (portrait){
        camera.position.set(7.6, 6.1, 8.6);
      } else {
        camera.position.set(7.0, 5.2, 7.6);
      }
      camera.lookAt(0, 1.0, 0);
    }
    fitCamera();

    scene.add(new THREE.HemisphereLight(0xfff7f0, 0xdfeaff, 0.75));

    const key = new THREE.DirectionalLight(0xffffff, 0.95);
    key.position.set(6, 9, 5);
    key.castShadow = true;
    key.shadow.mapSize.set(2048, 2048);
    key.shadow.camera.left = -12;
    key.shadow.camera.right = 12;
    key.shadow.camera.top = 12;
    key.shadow.camera.bottom = -12;
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffe8f6, 0.45);
    fill.position.set(-7, 6, 2);
    scene.add(fill);

    const rim = new THREE.DirectionalLight(0xd7fff1, 0.35);
    rim.position.set(0, 6, -8);
    scene.add(rim);

    const floorMat = new THREE.MeshPhysicalMaterial({
      color: 0xf3f0ff,
      roughness: 0.92,
      metalness: 0.0,
      clearcoat: 0.05,
      clearcoatRoughness: 0.9
    });
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const backMat = new THREE.MeshPhysicalMaterial({
      color: 0xf6fff5,
      roughness: 0.95,
      metalness: 0.0
    });
    const back = new THREE.Mesh(new THREE.PlaneGeometry(40, 18), backMat);
    back.position.set(0, 9, -12);
    back.receiveShadow = true;
    scene.add(back);

    const sideMat = new THREE.MeshPhysicalMaterial({ color: 0xfff3f0, roughness: 0.97, metalness: 0.0 });
    const side = new THREE.Mesh(new THREE.PlaneGeometry(22, 14), sideMat);
    side.position.set(-12, 7, 0);
    side.rotation.y = Math.PI/2;
    scene.add(side);

    // ---------- Face textures: WHITE + BLACK dots ----------
    function makeFaceTexture(n){
      const c = document.createElement("canvas");
      c.width = 512; c.height = 512;
      const g = c.getContext("2d");

      g.fillStyle = "#ffffff";
      g.fillRect(0,0,512,512);

      const vign = g.createRadialGradient(170,150,60, 256,256,340);
      vign.addColorStop(0, "rgba(255,255,255,0)");
      vign.addColorStop(1, "rgba(0,0,0,0.08)");
      g.fillStyle = vign;
      g.fillRect(0,0,512,512);

      g.strokeStyle = "rgba(0,0,0,0.10)";
      g.lineWidth = 12;
      g.strokeRect(22,22,468,468);

      const pip = (x,y)=>{
        const r = 42;
        const pg = g.createRadialGradient(x-10,y-12,10, x,y,r);
        pg.addColorStop(0, "rgba(255,255,255,0.12)");
        pg.addColorStop(0.30, "rgba(255,255,255,0.02)");
        pg.addColorStop(0.31, "#111111");
        pg.addColorStop(1, "#000000");
        g.beginPath();
        g.fillStyle = pg;
        g.arc(x,y,r,0,Math.PI*2);
        g.fill();
      };

      const pos = {
        tl:[156,156], tc:[256,156], tr:[356,156],
        ml:[156,256], mc:[256,256], mr:[356,256],
        bl:[156,356], bc:[256,356], br:[356,356],
      };
      const layouts = {
        1:["mc"],
        2:["tl","br"],
        3:["tl","mc","br"],
        4:["tl","tr","bl","br"],
        5:["tl","tr","mc","bl","br"],
        6:["tl","tr","ml","mr","bl","br"],
      };
      layouts[n].forEach(k => pip(pos[k][0], pos[k][1]));

      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return tex;
    }

    const faceTex = {
      1: makeFaceTexture(1),
      2: makeFaceTexture(2),
      3: makeFaceTexture(3),
      4: makeFaceTexture(4),
      5: makeFaceTexture(5),
      6: makeFaceTexture(6),
    };

    const diceSize = 1.35;

    function buildDieMaterials(pastelTintHex){
      const tint = new THREE.Color(pastelTintHex);
      const mk = (tex) => new THREE.MeshPhysicalMaterial({
        map: tex,
        color: tint,
        roughness: 0.35,
        metalness: 0.0,
        clearcoat: 0.85,
        clearcoatRoughness: 0.22
      });
      return [
        mk(faceTex[3]), // right
        mk(faceTex[4]), // left
        mk(faceTex[2]), // top
        mk(faceTex[5]), // bottom
        mk(faceTex[1]), // front
        mk(faceTex[6]), // back
      ];
    }

    function makeDiceMesh(pastelTintHex){
      const geo = new THREE.BoxGeometry(diceSize, diceSize, diceSize);
      const mesh = new THREE.Mesh(geo, buildDieMaterials(pastelTintHex));
      mesh.castShadow = true;

      const edgeGeo = new THREE.EdgesGeometry(geo, 18);
      const edgeLines = new THREE.LineSegments(
        edgeGeo,
        new THREE.LineBasicMaterial({ color: 0x000000, transparent:true, opacity: 0.10 })
      );
      mesh.add(edgeLines);

      scene.add(mesh);
      return mesh;
    }

    const diceMeshA = makeDiceMesh(0xf6f1ff);
    const diceMeshB = makeDiceMesh(0xf1fff6);

    // ---------- CANNON ----------
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });

    const diceMat = new CANNON.Material("dice");
    const floorMatP = new CANNON.Material("floor");

    world.addContactMaterial(new CANNON.ContactMaterial(diceMat, floorMatP, {
      friction: 0.30,
      restitution: 0.45
    }));
    world.addContactMaterial(new CANNON.ContactMaterial(diceMat, diceMat, {
      friction: 0.28,
      restitution: 0.38
    }));

    const floorBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Plane(), material: floorMatP });
    floorBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
    world.addBody(floorBody);

    // ✅ Invisible tray walls to stop dice flying off-screen
    function addWall({ x=0, z=0, hx=6, hz=0.15, height=0.9 }){
      const wall = new CANNON.Body({ type: CANNON.Body.STATIC, material: floorMatP });
      wall.addShape(new CANNON.Box(new CANNON.Vec3(hx, height/2, hz)));
      wall.position.set(x, height/2, z);
      world.addBody(wall);
      return wall;
    }

    // Tray dimensions (tuned for mobile)
    const TRAY_HALF = 3.6;
    addWall({ x: 0, z:  TRAY_HALF, hx: TRAY_HALF, hz: 0.18, height: 1.0 }); // far
    addWall({ x: 0, z: -TRAY_HALF, hx: TRAY_HALF, hz: 0.18, height: 1.0 }); // near
    addWall({ x:  TRAY_HALF, z: 0, hx: 0.18, hz: TRAY_HALF, height: 1.0 }); // right
    addWall({ x: -TRAY_HALF, z: 0, hx: 0.18, hz: TRAY_HALF, height: 1.0 }); // left

    function makeDiceBody(){
      const body = new CANNON.Body({
        mass: 1.1,
        shape: new CANNON.Box(new CANNON.Vec3(diceSize/2, diceSize/2, diceSize/2)),
        material: diceMat,
        linearDamping: 0.26,     // slightly more damping = less skating
        angularDamping: 0.26,
        allowSleep: true,
        sleepTimeLimit: 0.25,
        sleepSpeedLimit: 0.22
      });
      world.addBody(body);
      return body;
    }

    const diceBodyA = makeDiceBody();
    const diceBodyB = makeDiceBody();

    const TIP_X = THREE.MathUtils.degToRad(54.7356);
    const TIP_Y = THREE.MathUtils.degToRad(45);

    function setTipPoseTwo(){
      diceBodyA.position.set(-1.2, 2.6, 0);
      diceBodyB.position.set( 1.2, 2.6, 0);

      diceBodyA.velocity.setZero(); diceBodyA.angularVelocity.setZero();
      diceBodyB.velocity.setZero(); diceBodyB.angularVelocity.setZero();

      diceBodyA.quaternion.setFromEuler(TIP_X, TIP_Y, 0);
      diceBodyB.quaternion.setFromEuler(TIP_X, TIP_Y, 0);

      diceBodyA.wakeUp(); diceBodyB.wakeUp();

      outA.textContent = "—";
      outB.textContent = "—";
    }
    setTipPoseTwo();

    function getUpFaceNumber(body){
      const q = body.quaternion;
      const wx = q.vmult(new CANNON.Vec3(1,0,0));
      const wy = q.vmult(new CANNON.Vec3(0,1,0));
      const wz = q.vmult(new CANNON.Vec3(0,0,1));
      const candidates = [
        { face: 3, v:  wx.y },
        { face: 4, v: -wx.y },
        { face: 2, v:  wy.y },
        { face: 5, v: -wy.y },
        { face: 1, v:  wz.y },
        { face: 6, v: -wz.y },
      ];
      candidates.sort((a,b)=> b.v - a.v);
      return candidates[0].face;
    }

    let rolling = false;
    let settleTimer = null;
    let asleepA = false, asleepB = false;

    function finishIfDone(){
      if (!rolling) return;
      if (asleepA && asleepB){
        rolling = false;
        rollBtn.disabled = false;

        const a = getUpFaceNumber(diceBodyA);
        const b = getUpFaceNumber(diceBodyB);

        outA.textContent = a;
        outB.textContent = b;

        playDing();

        const { combined, quote } = funQuoteFor(a, b);
        openModal({ combined, a, b, quote });
      }
    }

    diceBodyA.addEventListener("sleep", () => { asleepA = true; finishIfDone(); });
    diceBodyB.addEventListener("sleep", () => { asleepB = true; finishIfDone(); });

    async function rollTwo(){
      if (rolling) return;
      await ensureAudio();

      rolling = true;
      rollBtn.disabled = true;
      outA.textContent = "…";
      outB.textContent = "…";
      asleepA = false; asleepB = false;

      closeModal();
      if (settleTimer) clearTimeout(settleTimer);

      playRollSequence();

      // reduce power on small screens
      const portrait = window.innerHeight > window.innerWidth;
      const impulseScale = portrait ? 0.75 : 1.0;
      const angScale = portrait ? 0.85 : 1.0;

      diceBodyA.position.set(-1.45 + (Math.random()-0.5)*0.25, 3.1, (Math.random()-0.5)*0.25);
      diceBodyB.position.set( 1.45 + (Math.random()-0.5)*0.25, 3.1, (Math.random()-0.5)*0.25);

      diceBodyA.velocity.setZero(); diceBodyA.angularVelocity.setZero();
      diceBodyB.velocity.setZero(); diceBodyB.angularVelocity.setZero();

      diceBodyA.quaternion.setFromEuler(
        TIP_X + THREE.MathUtils.degToRad((Math.random()*10-5)),
        TIP_Y + THREE.MathUtils.degToRad((Math.random()*10-5)),
        THREE.MathUtils.degToRad(Math.random()*360)
      );
      diceBodyB.quaternion.setFromEuler(
        TIP_X + THREE.MathUtils.degToRad((Math.random()*10-5)),
        TIP_Y + THREE.MathUtils.degToRad((Math.random()*10-5)),
        THREE.MathUtils.degToRad(Math.random()*360)
      );

      diceBodyA.wakeUp(); diceBodyB.wakeUp();

      const impA = new CANNON.Vec3((1.4 + Math.random()*1.8) * impulseScale, 0, ((Math.random()*2-1)*2.6) * impulseScale);
      const impB = new CANNON.Vec3((-1.4 - Math.random()*1.8) * impulseScale, 0, ((Math.random()*2-1)*2.6) * impulseScale);

      diceBodyA.applyImpulse(impA, diceBodyA.position);
      diceBodyB.applyImpulse(impB, diceBodyB.position);

      diceBodyA.angularVelocity.set((Math.random()*2-1)*12*angScale, (Math.random()*2-1)*14*angScale, (Math.random()*2-1)*12*angScale);
      diceBodyB.angularVelocity.set((Math.random()*2-1)*12*angScale, (Math.random()*2-1)*14*angScale, (Math.random()*2-1)*12*angScale);

      settleTimer = setTimeout(() => {
        diceBodyA.velocity.scale(0.35, diceBodyA.velocity);
        diceBodyA.angularVelocity.scale(0.35, diceBodyA.angularVelocity);
        diceBodyB.velocity.scale(0.35, diceBodyB.velocity);
        diceBodyB.angularVelocity.scale(0.35, diceBodyB.angularVelocity);

        setTimeout(() => {
          asleepA = true; asleepB = true;
          finishIfDone();
        }, 450);
      }, 4200);
    }

    rollBtn.addEventListener("click", rollTwo);

    // tap anywhere to roll (except UI/modal)
    window.addEventListener("pointerdown", (e) => {
      if (modalBackdrop.style.display === "flex") return;
      if (e.target.closest && (e.target.closest("#btnRow") || e.target.closest("#soundWrap"))) return;
      rollTwo();
    }, { passive: true });

    // also resume audio on mobile gestures
    soundToggle.addEventListener("pointerdown", ensureAudio, { passive: true });

    window.addEventListener("keydown", (e)=>{
      if (e.code === "Space"){ e.preventDefault(); rollTwo(); }
      if (e.code === "KeyR"){ setTipPoseTwo(); }
    });

    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 1/30);
      world.step(1/60, dt, 3);

      diceMeshA.position.copy(diceBodyA.position);
      diceMeshA.quaternion.copy(diceBodyA.quaternion);

      diceMeshB.position.copy(diceBodyB.position);
      diceMeshB.quaternion.copy(diceBodyB.quaternion);

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      fitCamera();
    });
  </script>
</body>
</html>
